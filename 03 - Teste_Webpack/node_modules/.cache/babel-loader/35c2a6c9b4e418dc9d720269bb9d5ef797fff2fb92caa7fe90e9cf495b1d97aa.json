{"ast":null,"code":"\"use strict\";\n\nvar util = require('util');\nvar duplexer = require('duplexer');\nvar out = require('through2')();\nvar parser = require('tap-out')();\nvar _ = require('lodash');\nvar push = function (tapObj) {\n  transformers[tapObj.type].forEach(function (fn) {\n    var res = fn(tapObj);\n    out.push(typeof res === 'undefined' ? '.' : res);\n  });\n};\n\n// All tap-out parse events. See comments below.\n//\nvar events = [\n// type - this will always be assert\n// name - the name of the assertion\n// raw - the raw output before it was parsed\n// number - the number of the assertion\n// ok - whether the assertion passed or failed\n// test - the number of the test this assertion belongs to\n//\n'assert',\n// type - this will always be result\n// name - the name of the result\n// raw - the raw output before it was parsed\n// count - the number of tests related to this result\n//\n'result',\n// When a test is set up\n// \n// type - value will always be test\n// name - name of the test\n// raw - the raw output before it was parsed\n// number - the number of the test\n//\n'test',\n// type - this will always be version\n// raw - the raw output before it was parsed\n//\n'version'];\n\n// Create default transformer collection for all events. \n// This default is replaced by the first call to #transform\n//\nvar transformers = events.reduce(function (coll, ev) {\n  coll[ev] = coll[ev] || [];\n  coll[ev].push(function $baseTransformer(tapObj) {\n    // Just send back the raw TAP output\n    //\n    return util.format('\\nTAP> %s\\n', tapObj.raw);\n  });\n  return coll;\n}, {});\n\n// Bind all parse events to #push. Each event emits an object as\n// described in the comments. #push does the work of catching, \n// transforming, and pushing back into the stream. \n//\nevents.forEach(function (event) {\n  parser.on(event, push);\n});\n\n// Prime the output pump by creating a newline.\n//\nout.push('\\n');\nmodule.exports = function (cfg) {\n  // It's ok to send no configuration.\n  //\n  cfg = typeof cfg === 'undefined' ? {} : cfg;\n  var stream = duplexer(parser, out);\n  if (!_.isPlainObject(cfg)) {\n    throw new Error('apt-tap #configure expects an Object');\n  }\n  Object.keys(cfg).forEach(function (event) {\n    if (!~events.indexOf(event)) {\n      throw new Error('Invalid event name received by apt-tap -> ' + event);\n    }\n\n    // Make into Array if not. This allows a single\n    // Function to be passed, OR an Array of functions.\n    //\n    if (!_.isArray(cfg[event])) {\n      cfg[event] = [cfg[event]];\n    }\n    cfg[event].forEach(function (fn) {\n      if (!_.isFunction(fn)) {\n        throw new Error('apt-tap expects a Function or Array of Functions. Received -> ' + fn + ' for event -> ' + event);\n      }\n\n      // Remove default transformer when any userland transformer \n      // is added. \n      //\n      if (transformers[event][0].name === '$baseTransformer') {\n        transformers[event].shift();\n      }\n      transformers[event].push(fn);\n    });\n  });\n  return stream;\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}