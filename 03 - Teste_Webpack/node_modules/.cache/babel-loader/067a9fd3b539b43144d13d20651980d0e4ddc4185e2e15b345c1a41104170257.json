{"ast":null,"code":"'use strict';\n\nvar PassThrough = require('readable-stream/passthrough');\nvar split = require('split');\nvar trim = require('trim');\nvar util = require('util');\nvar EventEmitter = require('events').EventEmitter;\nvar reemit = require('re-emitter');\nvar expr = require('./lib/utils/regexes');\nvar parseLine = require('./lib/parse-line');\nfunction Parser() {\n  if (!(this instanceof Parser)) {\n    return new Parser();\n  }\n  EventEmitter.call(this);\n  this.results = {\n    tests: [],\n    asserts: [],\n    versions: [],\n    results: [],\n    comments: [],\n    plans: [],\n    pass: [],\n    fail: []\n  };\n  this.testNumber = 0;\n  this.previousLine = '';\n  this.currentNextLineError = null;\n  this.writingErrorOutput = false;\n  this.writingErrorStackOutput = false;\n  this.tmpErrorOutput = '';\n}\nutil.inherits(Parser, EventEmitter);\nParser.prototype.handleLine = function handleLine(line) {\n  var parsed = parseLine(line);\n\n  // This will handle all the error stuff\n  this._handleError(line);\n\n  // This is weird, but it's the only way to distinguish a\n  // console.log type output from an error output\n  if (!this.writingErrorOutput && !parsed && !isErrorOutputEnd(line) && !isRawTapTestStatus(line)) {\n    var comment = {\n      type: 'comment',\n      raw: line,\n      test: this.testNumber\n    };\n    this.emit('comment', comment);\n    this.results.comments.push(comment);\n  }\n\n  // Invalid line\n  if (!parsed) {\n    return;\n  }\n\n  // Handle tests\n  if (parsed.type === 'test') {\n    this.testNumber += 1;\n    parsed.number = this.testNumber;\n  }\n\n  // Handle asserts\n  if (parsed.type === 'assert') {\n    parsed.test = this.testNumber;\n    this.results[parsed.ok ? 'pass' : 'fail'].push(parsed);\n    if (parsed.ok) {\n      // No need to have the error object\n      // in a passing assertion\n      delete parsed.error;\n      this.emit('pass', parsed);\n    }\n  }\n  if (!isOkLine(this.previousLine)) {\n    this.emit(parsed.type, parsed);\n    this.results[parsed.type + 's'].push(parsed);\n  }\n\n  // This is all so we can determine if the \"# ok\" output on the last line\n  // should be skipped\n  function isOkLine(previousLine) {\n    return line === '# ok' && previousLine.indexOf('# pass') > -1;\n  }\n  this.previousLine = line;\n};\nParser.prototype._handleError = function _handleError(line) {\n  // Start of error output\n  if (isErrorOutputStart(line)) {\n    this.writingErrorOutput = true;\n    this.lastAsserRawErrorString = '';\n  }\n  // End of error output\n  else if (isErrorOutputEnd(line)) {\n    this.writingErrorOutput = false;\n    this.currentNextLineError = null;\n    this.writingErrorStackOutput = false;\n\n    // Emit error here so it has the full error message with it\n    var lastAssert = this.results.fail[this.results.fail.length - 1];\n    if (this.tmpErrorOutput) {\n      lastAssert.error.stack = this.tmpErrorOutput;\n      this.tmpErrorOutput = '';\n    }\n\n    // right-trimmed raw error string\n    lastAssert.error.raw = this.lastAsserRawErrorString.replace(/\\s+$/g, '');\n    this.emit('fail', lastAssert);\n  }\n  // Append to stack\n  else if (this.writingErrorStackOutput) {\n    this.tmpErrorOutput += trim(line) + '\\n';\n  }\n  // Not the beginning of the error message but it's the body\n  else if (this.writingErrorOutput) {\n    var lastAssert = this.results.fail[this.results.fail.length - 1];\n    var m = splitFirst(trim(line), ':');\n\n    // Rebuild raw error output\n    this.lastAsserRawErrorString += line + '\\n';\n    if (m[0] === 'stack') {\n      this.writingErrorStackOutput = true;\n      return;\n    }\n    var msg = trim((m[1] || '').replace(/['\"]+/g, ''));\n    if (m[0] === 'at') {\n      // Example string: Object.async.eachSeries (/Users/scott/www/modules/nash/node_modules/async/lib/async.js:145:20)\n\n      msg = msg.split(' ')[1].replace('(', '').replace(')', '');\n      var values = msg.split(':');\n      var file = values.slice(0, values.length - 2).join(':');\n      msg = {\n        file: file,\n        line: values[values.length - 2],\n        character: values[values.length - 1]\n      };\n    }\n\n    // This is a plan failure\n    if (lastAssert.name === 'plan != count') {\n      lastAssert.type = 'plan';\n      delete lastAssert.error.at;\n      lastAssert.error.operator = 'count';\n\n      // Need to set this value\n      if (m[0] === 'actual') {\n        lastAssert.error.actual = trim(m[1]);\n      }\n    }\n\n    // outputting expected/actual object or array\n    if (this.currentNextLineError) {\n      lastAssert.error[this.currentNextLineError] = trim(line);\n      this.currentNextLineError = null;\n    } else if (trim(m[1]) === '|-') {\n      this.currentNextLineError = m[0];\n    } else {\n      lastAssert.error[m[0]] = msg;\n    }\n  }\n};\nmodule.exports = function (done) {\n  done = done || function () {};\n  var stream = new PassThrough();\n  var parser = Parser();\n  reemit(parser, stream, ['test', 'assert', 'version', 'result', 'pass', 'fail', 'comment', 'plan']);\n  stream.pipe(split()).on('data', function (data) {\n    if (!data) {\n      return;\n    }\n    var line = data.toString();\n    parser.handleLine(line);\n  }).on('close', function () {\n    stream.emit('output', parser.results);\n    done(null, parser.results);\n  }).on('error', done);\n  return stream;\n};\nmodule.exports.Parser = Parser;\nfunction isErrorOutputStart(line) {\n  return line.indexOf('  ---') === 0;\n}\nfunction isErrorOutputEnd(line) {\n  return line.indexOf('  ...') === 0;\n}\nfunction splitFirst(str, pattern) {\n  var parts = str.split(pattern);\n  if (parts.length <= 1) {\n    return parts;\n  }\n  return [parts[0], parts.slice(1).join(pattern)];\n}\nfunction isRawTapTestStatus(str) {\n  var rawTapTestStatusRegex = new RegExp('(\\\\d+)(\\\\.)(\\\\.)(\\\\d+)');\n  ;\n  return rawTapTestStatusRegex.exec(str);\n}","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}