{"ast":null,"code":"\"use strict\";\n\nvar Path = require('path');\nvar fs = require('fs');\nvar util = require('util');\nvar glob = require('glob');\nvar test = require('blue-tape').test;\nvar harness = require('apt-tap');\nvar Promise = require('bluebird');\nvar _ = require('lodash');\nPromise.longStackTraces();\n\n// @param opts {Object} Configuration options\n// @param [opts.testDir]    The directory to run tests in. Should be absolute.\n//                          Default process.cwd()\n// @param [opts.specDir]    String name of folder under #testDir where test spec\n//                          files are located. Default `spec`\n// @param [opts.fixtureDir] String name of folder under #testDir where test fixture\n//                          files are located. Default `fixture`\n// @param [opts.reporter]   A string argument suitable for #require indicating where\n//                          to find the TAP reporter suitable for @apt-tap.\n//                          Default 'apt-tap-basic'\n// @param [opts.globalFixtures] An Array of fixtures that should wrap every test.\n//\nmodule.exports = function (opts) {\n  var testDir = opts.testDir || process.cwd();\n  var specDir = opts.specDir || 'spec';\n  var fixtureDir = opts.fixtureDir || 'fixture';\n  var globalFixtures = _.isArray(opts.globalFixtures) ? opts.globalFixtures : [];\n\n  // If a non-reachable reporter is sent, unadorned TAP output will result\n  // (apt-tap accepts a null argument as valid). So, it is ok to not\n  // send a reporter simply by defining #reporter as anything other than undefined,\n  // such as Boolean false.\n  //\n  var reporter;\n  try {\n    reporter = require(typeof opts.reporter !== 'undefined' ? opts.reporter : 'apt-tap-basic');\n  } catch (e) {}\n\n  // To run specific tests, pass them along via command line.\n  // @example\t> node test fixtureA fixtureB ...\n  //\n  var tests = process.argv.splice(2);\n  if (tests.length) {\n    tests = tests.map(function (name) {\n      return util.format(Path.resolve(testDir) + '/%s/%s.js', specDir, name);\n    });\n  } else {\n    // Otherwise, run them all\n    //\n    tests = glob.sync(Path.resolve(testDir, specDir, '**/*.js'));\n  }\n\n  // Grab the requested fixture and merge into #into\n  //\n  function tryToMergeFixture(into, fromPath, test, isGlobal) {\n    var fixture = {};\n    var filebase = Path.basename(fromPath, '.js');\n    var f;\n    try {\n      f = require(fromPath);\n\n      // If the fixture returns a function, expect that the fixture\n      // itself will be returned by calling that function; call that function\n      // with a reference to the test harness.\n      //\n      if (typeof f === 'function') {\n        f = f(test);\n      }\n\n      // Fail if a fixture Object was not produced.\n      //\n      if (_.isPlainObject(f)) {\n        fixture = f;\n      } else {\n        throw new Error(util.format('Fixture <%s> must be Object, or a Function that returns an Object. Received: %s -> %s', filebase, typeof f, f));\n      }\n      into = _.merge(into, fixture);\n    } catch (err) {\n      // If a requested global fixture was not found, report that.\n      // \"local\" fixtures don't necessarily exist for all spec files\n      // so not found errors are ok.\n      //\n      if (isGlobal) {\n        test.fail(util.format('Unable to load global fixture <%s> -> %s', filebase, err.message));\n      }\n    }\n  }\n\n  // Tap into stream of tests, report, and pipe results to\n  // any writable stream.\n  //\n  test.createStream().pipe(harness(reporter)).pipe(process.stdout);\n  Promise.reduce(tests, function (prev, path) {\n    return new Promise(function (resolve, reject) {\n      // test(path...)\n      // The test file #path is used here as the test name.\n      // You can change that to any other String you'd like.\n      //\n      return test(path, function (t) {\n        var fixtures = {};\n\n        // Merge the requested global fixtures.\n        //\n        globalFixtures.forEach(function (gf) {\n          tryToMergeFixture(fixtures, Path.resolve(testDir, fixtureDir, gf), t, true);\n        });\n\n        // Merge the test-specific fixture, if any.\n        //\n        tryToMergeFixture(fixtures, Path.resolve(testDir, fixtureDir, Path.basename(path)), t);\n        return require(path).bind(fixtures)(t, Promise).finally(resolve);\n      });\n    });\n  }, []).finally(process.exit);\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}