{"ast":null,"code":"'use strict';\n\nvar deepEqual = require('deep-equal');\nvar defined = require('defined');\nvar path = require('path');\nvar inherits = require('inherits');\nvar EventEmitter = require('events').EventEmitter;\nvar has = require('has');\nvar isRegExp = require('is-regex');\nvar trim = require('string.prototype.trim');\nvar callBound = require('call-bind/callBound');\nvar forEach = require('for-each');\nvar inspect = require('object-inspect');\nvar isEnumerable = callBound('Object.prototype.propertyIsEnumerable');\nvar toLowerCase = callBound('String.prototype.toLowerCase');\nvar $exec = callBound('RegExp.prototype.exec');\nvar objectToString = callBound('Object.prototype.toString');\nvar nextTick = typeof setImmediate !== 'undefined' ? setImmediate : process.nextTick;\nvar safeSetTimeout = setTimeout;\nvar safeClearTimeout = clearTimeout;\n\n// eslint-disable-next-line no-unused-vars\nfunction getTestArgs(name_, opts_, cb_) {\n  var name = '(anonymous)';\n  var opts = {};\n  var cb;\n  for (var i = 0; i < arguments.length; i++) {\n    var arg = arguments[i];\n    var t = typeof arg;\n    if (t === 'string') {\n      name = arg;\n    } else if (t === 'object') {\n      opts = arg || opts;\n    } else if (t === 'function') {\n      cb = arg;\n    }\n  }\n  return {\n    name: name,\n    opts: opts,\n    cb: cb\n  };\n}\nfunction Test(name_, opts_, cb_) {\n  if (!(this instanceof Test)) {\n    return new Test(name_, opts_, cb_);\n  }\n  var args = getTestArgs(name_, opts_, cb_);\n  this.readable = true;\n  this.name = args.name || '(anonymous)';\n  this.assertCount = 0;\n  this.pendingCount = 0;\n  this._skip = args.opts.skip || false;\n  this._todo = args.opts.todo || false;\n  this._timeout = args.opts.timeout;\n  this._plan = undefined;\n  this._cb = args.cb;\n  this._progeny = [];\n  this._teardown = [];\n  this._ok = true;\n  var depthEnvVar = process.env.NODE_TAPE_OBJECT_PRINT_DEPTH;\n  if (args.opts.objectPrintDepth) {\n    this._objectPrintDepth = args.opts.objectPrintDepth;\n  } else if (depthEnvVar) {\n    if (toLowerCase(depthEnvVar) === 'infinity') {\n      this._objectPrintDepth = Infinity;\n    } else {\n      this._objectPrintDepth = depthEnvVar;\n    }\n  } else {\n    this._objectPrintDepth = 5;\n  }\n  for (var prop in this) {\n    this[prop] = function bind(self, val) {\n      if (typeof val === 'function') {\n        return function bound() {\n          return val.apply(self, arguments);\n        };\n      }\n      return val;\n    }(this, this[prop]);\n  }\n}\ninherits(Test, EventEmitter);\nTest.prototype.run = function run() {\n  this.emit('prerun');\n  if (!this._cb || this._skip) {\n    this._end();\n    return;\n  }\n  if (this._timeout != null) {\n    this.timeoutAfter(this._timeout);\n  }\n  this._cb(this);\n  this.emit('run');\n};\nTest.prototype.test = function (name, opts, cb) {\n  var self = this;\n  var t = new Test(name, opts, cb);\n  this._progeny.push(t);\n  this.pendingCount++;\n  this.emit('test', t);\n  t.on('prerun', function () {\n    self.assertCount++;\n  });\n  if (!self._pendingAsserts()) {\n    nextTick(function () {\n      self._end();\n    });\n  }\n  nextTick(function () {\n    if (!self._plan && self.pendingCount == self._progeny.length) {\n      self._end();\n    }\n  });\n};\nTest.prototype.comment = function (msg) {\n  var that = this;\n  forEach(trim(msg).split('\\n'), function (aMsg) {\n    that.emit('result', trim(aMsg).replace(/^#\\s*/, ''));\n  });\n};\nTest.prototype.plan = function (n) {\n  this._plan = n;\n  this.emit('plan', n);\n};\nTest.prototype.timeoutAfter = function (ms) {\n  if (!ms) {\n    throw new Error('timeoutAfter requires a timespan');\n  }\n  var self = this;\n  var timeout = safeSetTimeout(function () {\n    self.fail(self.name + ' timed out after ' + ms + 'ms');\n    self.end();\n  }, ms);\n  this.once('end', function () {\n    safeClearTimeout(timeout);\n  });\n};\nTest.prototype.end = function end(err) {\n  if (arguments.length >= 1 && !!err) {\n    this.ifError(err);\n  }\n  if (this.calledEnd) {\n    this.fail('.end() already called');\n  }\n  this.calledEnd = true;\n  this._end();\n};\nTest.prototype.teardown = function (fn) {\n  if (typeof fn !== 'function') {\n    this.fail('teardown: ' + inspect(fn) + ' is not a function');\n  } else {\n    this._teardown.push(fn);\n  }\n};\nTest.prototype._end = function (err) {\n  var self = this;\n  if (this._progeny.length) {\n    var t = this._progeny.shift();\n    t.on('end', function () {\n      self._end();\n    });\n    t.run();\n    return;\n  }\n  function completeEnd() {\n    if (!self.ended) {\n      self.emit('end');\n    }\n    var pendingAsserts = self._pendingAsserts();\n    if (!self._planError && self._plan !== undefined && pendingAsserts) {\n      self._planError = true;\n      self.fail('plan != count', {\n        expected: self._plan,\n        actual: self.assertCount\n      });\n    }\n    self.ended = true;\n  }\n  function next(i) {\n    if (i === self._teardown.length) {\n      completeEnd();\n      return;\n    }\n    var fn = self._teardown[i];\n    var res;\n    try {\n      res = fn();\n    } catch (e) {\n      self.fail(e);\n    }\n    if (res && typeof res.then === 'function') {\n      res.then(function () {\n        next(++i);\n      }, function (_err) {\n        err = err || _err;\n      });\n    } else {\n      next(++i);\n    }\n  }\n  if (this._teardown.length > 0) {\n    next(0);\n  } else {\n    completeEnd();\n  }\n};\nTest.prototype._exit = function () {\n  if (this._plan !== undefined && !this._planError && this.assertCount !== this._plan) {\n    this._planError = true;\n    this.fail('plan != count', {\n      expected: this._plan,\n      actual: this.assertCount,\n      exiting: true\n    });\n  } else if (!this.ended) {\n    this.fail('test exited without ending: ' + this.name, {\n      exiting: true\n    });\n  }\n};\nTest.prototype._pendingAsserts = function () {\n  if (this._plan === undefined) {\n    return 1;\n  }\n  return this._plan - (this._progeny.length + this.assertCount);\n};\nTest.prototype._assert = function assert(ok, opts) {\n  var self = this;\n  var extra = opts.extra || {};\n  ok = !!ok || !!extra.skip;\n  var res = {\n    id: self.assertCount++,\n    ok: ok,\n    skip: defined(extra.skip, opts.skip),\n    todo: defined(extra.todo, opts.todo, self._todo),\n    name: defined(extra.message, opts.message, '(unnamed assert)'),\n    operator: defined(extra.operator, opts.operator),\n    objectPrintDepth: self._objectPrintDepth\n  };\n  if (has(opts, 'actual') || has(extra, 'actual')) {\n    res.actual = defined(extra.actual, opts.actual);\n  }\n  if (has(opts, 'expected') || has(extra, 'expected')) {\n    res.expected = defined(extra.expected, opts.expected);\n  }\n  this._ok = !!(this._ok && ok);\n  if (!ok && !res.todo) {\n    res.error = defined(extra.error, opts.error, new Error(res.name));\n  }\n  if (!ok) {\n    var e = new Error('exception');\n    var err = (e.stack || '').split('\\n');\n    var dir = __dirname + path.sep;\n    for (var i = 0; i < err.length; i++) {\n      /*\n                   Stack trace lines may resemble one of the following. We need\n                   to correctly extract a function name (if any) and path / line\n                   number for each line.\n                        at myFunction (/path/to/file.js:123:45)\n                       at myFunction (/path/to/file.other-ext:123:45)\n                       at myFunction (/path to/file.js:123:45)\n                       at myFunction (C:\\path\\to\\file.js:123:45)\n                       at myFunction (/path/to/file.js:123)\n                       at Test.<anonymous> (/path/to/file.js:123:45)\n                       at Test.bound [as run] (/path/to/file.js:123:45)\n                       at /path/to/file.js:123:45\n                    Regex has three parts. First is non-capturing group for 'at '\n                   (plus anything preceding it).\n                        /^(?:[^\\s]*\\s*\\bat\\s+)/\n                    Second captures function call description (optional). This is\n                   not necessarily a valid JS function name, but just what the\n                   stack trace is using to represent a function call. It may look\n                   like `<anonymous>` or 'Test.bound [as run]'.\n                    For our purposes, we assume that, if there is a function\n                   name, it's everything leading up to the first open\n                   parentheses (trimmed) before our pathname.\n                        /(?:(.*)\\s+\\()?/\n                    Last part captures file path plus line no (and optional\n                   column no).\n                        /((?:\\/|[a-zA-Z]:\\\\)[^:\\)]+:(\\d+)(?::(\\d+))?)\\)?/\n               */\n      var re = /^(?:[^\\s]*\\s*\\bat\\s+)(?:(.*)\\s+\\()?((?:\\/|[a-zA-Z]:\\\\)[^:)]+:(\\d+)(?::(\\d+))?)\\)?$/;\n      var lineWithTokens = err[i].replace(process.cwd(), '/$CWD').replace(__dirname, '/$TEST');\n      var m = re.exec(lineWithTokens);\n      if (!m) {\n        continue;\n      }\n      var callDescription = m[1] || '<anonymous>';\n      var filePath = m[2].replace('/$CWD', process.cwd()).replace('/$TEST', __dirname);\n      if (filePath.slice(0, dir.length) === dir) {\n        continue;\n      }\n\n      // Function call description may not (just) be a function name. Try to extract function name by looking at first \"word\" only.\n      res.functionName = callDescription.split(/\\s+/)[0];\n      res.file = filePath;\n      res.line = Number(m[3]);\n      if (m[4]) {\n        res.column = Number(m[4]);\n      }\n      res.at = callDescription + ' (' + filePath + ')';\n      break;\n    }\n  }\n  self.emit('result', res);\n  var pendingAsserts = self._pendingAsserts();\n  if (!pendingAsserts) {\n    if (extra.exiting) {\n      self._end();\n    } else {\n      nextTick(function () {\n        self._end();\n      });\n    }\n  }\n  if (!self._planError && pendingAsserts < 0) {\n    self._planError = true;\n    self.fail('plan != count', {\n      expected: self._plan,\n      actual: self._plan - pendingAsserts\n    });\n  }\n};\nTest.prototype.fail = function (msg, extra) {\n  this._assert(false, {\n    message: msg,\n    operator: 'fail',\n    extra: extra\n  });\n};\nTest.prototype.pass = function (msg, extra) {\n  this._assert(true, {\n    message: msg,\n    operator: 'pass',\n    extra: extra\n  });\n};\nTest.prototype.skip = function (msg, extra) {\n  this._assert(true, {\n    message: msg,\n    operator: 'skip',\n    skip: true,\n    extra: extra\n  });\n};\n\n// eslint-disable-next-line func-style\nvar tapeAssert = function assert(value, msg, extra) {\n  this._assert(value, {\n    message: defined(msg, 'should be truthy'),\n    operator: 'ok',\n    expected: true,\n    actual: value,\n    extra: extra\n  });\n};\nTest.prototype.ok = Test.prototype['true'] = Test.prototype.assert = tapeAssert;\nfunction notOK(value, msg, extra) {\n  this._assert(!value, {\n    message: defined(msg, 'should be falsy'),\n    operator: 'notOk',\n    expected: false,\n    actual: value,\n    extra: extra\n  });\n}\nTest.prototype.notOk = Test.prototype['false'] = Test.prototype.notok = notOK;\nfunction error(err, msg, extra) {\n  this._assert(!err, {\n    message: defined(msg, String(err)),\n    operator: 'error',\n    actual: err,\n    extra: extra\n  });\n}\nTest.prototype.error = Test.prototype.ifError = Test.prototype.ifErr = Test.prototype.iferror = error;\nfunction equal(a, b, msg, extra) {\n  this._assert(a === b, {\n    message: defined(msg, 'should be equal'),\n    operator: 'equal',\n    actual: a,\n    expected: b,\n    extra: extra\n  });\n}\nTest.prototype.equal = Test.prototype.equals = Test.prototype.isEqual = Test.prototype.is = Test.prototype.strictEqual = Test.prototype.strictEquals = equal;\nfunction notEqual(a, b, msg, extra) {\n  this._assert(a !== b, {\n    message: defined(msg, 'should not be equal'),\n    operator: 'notEqual',\n    actual: a,\n    expected: b,\n    extra: extra\n  });\n}\nTest.prototype.notEqual = Test.prototype.notEquals = Test.prototype.notStrictEqual = Test.prototype.notStrictEquals = Test.prototype.isNotEqual = Test.prototype.isNot = Test.prototype.not = Test.prototype.doesNotEqual = Test.prototype.isInequal = notEqual;\nfunction tapeDeepEqual(a, b, msg, extra) {\n  this._assert(deepEqual(a, b, {\n    strict: true\n  }), {\n    message: defined(msg, 'should be equivalent'),\n    operator: 'deepEqual',\n    actual: a,\n    expected: b,\n    extra: extra\n  });\n}\nTest.prototype.deepEqual = Test.prototype.deepEquals = Test.prototype.isEquivalent = Test.prototype.same = tapeDeepEqual;\nfunction deepLooseEqual(a, b, msg, extra) {\n  this._assert(deepEqual(a, b), {\n    message: defined(msg, 'should be equivalent'),\n    operator: 'deepLooseEqual',\n    actual: a,\n    expected: b,\n    extra: extra\n  });\n}\nTest.prototype.deepLooseEqual = Test.prototype.looseEqual = Test.prototype.looseEquals = deepLooseEqual;\nfunction notDeepEqual(a, b, msg, extra) {\n  this._assert(!deepEqual(a, b, {\n    strict: true\n  }), {\n    message: defined(msg, 'should not be equivalent'),\n    operator: 'notDeepEqual',\n    actual: a,\n    expected: b,\n    extra: extra\n  });\n}\nTest.prototype.notDeepEqual = Test.prototype.notDeepEquals = Test.prototype.notEquivalent = Test.prototype.notDeeply = Test.prototype.notSame = Test.prototype.isNotDeepEqual = Test.prototype.isNotDeeply = Test.prototype.isNotEquivalent = Test.prototype.isInequivalent = notDeepEqual;\nfunction notDeepLooseEqual(a, b, msg, extra) {\n  this._assert(!deepEqual(a, b), {\n    message: defined(msg, 'should be equivalent'),\n    operator: 'notDeepLooseEqual',\n    actual: a,\n    expected: b,\n    extra: extra\n  });\n}\nTest.prototype.notDeepLooseEqual = Test.prototype.notLooseEqual = Test.prototype.notLooseEquals = notDeepLooseEqual;\nTest.prototype['throws'] = function (fn, expected, msg, extra) {\n  if (typeof expected === 'string') {\n    msg = expected;\n    expected = undefined;\n  }\n  var caught;\n  try {\n    fn();\n  } catch (err) {\n    caught = {\n      error: err\n    };\n    if (Object(err) === err && 'message' in err && (!isEnumerable(err, 'message') || !has(err, 'message'))) {\n      try {\n        var message = err.message;\n        delete err.message;\n        err.message = message;\n      } catch (e) {/**/}\n    }\n  }\n  var passed = caught;\n  if (isRegExp(expected)) {\n    passed = $exec(expected, caught && caught.error) !== null;\n    expected = String(expected);\n  }\n  if (typeof expected === 'function' && caught) {\n    passed = caught.error instanceof expected;\n  }\n  this._assert(typeof fn === 'function' && passed, {\n    message: defined(msg, 'should throw'),\n    operator: 'throws',\n    actual: caught && caught.error,\n    expected: expected,\n    error: !passed && caught && caught.error,\n    extra: extra\n  });\n};\nTest.prototype.doesNotThrow = function (fn, expected, msg, extra) {\n  if (typeof expected === 'string') {\n    msg = expected;\n    expected = undefined;\n  }\n  var caught;\n  try {\n    fn();\n  } catch (err) {\n    caught = {\n      error: err\n    };\n  }\n  this._assert(!caught, {\n    message: defined(msg, 'should not throw'),\n    operator: 'throws',\n    actual: caught && caught.error,\n    expected: expected,\n    error: caught && caught.error,\n    extra: extra\n  });\n};\nTest.prototype.match = function match(string, regexp, msg, extra) {\n  if (!isRegExp(regexp)) {\n    this._assert(false, {\n      message: defined(msg, 'The \"regexp\" argument must be an instance of RegExp. Received type ' + typeof regexp + ' (' + inspect(regexp) + ')'),\n      operator: 'match',\n      actual: objectToString(regexp),\n      expected: '[object RegExp]',\n      extra: extra\n    });\n  } else if (typeof string !== 'string') {\n    this._assert(false, {\n      message: defined(msg, 'The \"string\" argument must be of type string. Received type ' + typeof string + ' (' + inspect(string) + ')'),\n      operator: 'match',\n      actual: string === null ? null : typeof string,\n      expected: 'string',\n      extra: extra\n    });\n  } else {\n    var matches = $exec(regexp, string) !== null;\n    var message = defined(msg, 'The input ' + (matches ? 'matched' : 'did not match') + ' the regular expression ' + inspect(regexp) + '. Input: ' + inspect(string));\n    this._assert(matches, {\n      message: message,\n      operator: 'match',\n      actual: string,\n      expected: regexp,\n      extra: extra\n    });\n  }\n};\nTest.prototype.doesNotMatch = function doesNotMatch(string, regexp, msg, extra) {\n  if (!isRegExp(regexp)) {\n    this._assert(false, {\n      message: defined(msg, 'The \"regexp\" argument must be an instance of RegExp. Received type ' + typeof regexp + ' (' + inspect(regexp) + ')'),\n      operator: 'doesNotMatch',\n      actual: objectToString(regexp),\n      expected: '[object RegExp]',\n      extra: extra\n    });\n  } else if (typeof string !== 'string') {\n    this._assert(false, {\n      message: defined(msg, 'The \"string\" argument must be of type string. Received type ' + typeof string + ' (' + inspect(string) + ')'),\n      operator: 'doesNotMatch',\n      actual: string === null ? null : typeof string,\n      expected: 'string',\n      extra: extra\n    });\n  } else {\n    var matches = $exec(regexp, string) !== null;\n    var message = defined(msg, 'The input ' + (matches ? 'was expected to not match' : 'did not match') + ' the regular expression ' + inspect(regexp) + '. Input: ' + inspect(string));\n    this._assert(!matches, {\n      message: message,\n      operator: 'doesNotMatch',\n      actual: string,\n      expected: regexp,\n      extra: extra\n    });\n  }\n};\n\n// eslint-disable-next-line no-unused-vars\nTest.skip = function (name_, _opts, _cb) {\n  var args = getTestArgs.apply(null, arguments);\n  args.opts.skip = true;\n  return new Test(args.name, args.opts, args.cb);\n};\nmodule.exports = Test;\n\n// vim: set softtabstop=4 shiftwidth=4:","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}